#!/usr/bin/env python3

'''Prepare directories and ancillary files to run rail-estimate
   script in parallel using HTCondor. 
   Dispatch jobs to the cluster.
   Write provenance info in text file. 

    Usage:
    
    run-pz-compute [options] [--] <process_id> <comment> <pz-compute-dir>
    run-pz-compute -h | --help
    run-pz-compute --version
                            
    Options:
    -h --help   Show help text.
    --version   Show version.
    -p <process id>, --process_id=<process id> Integer or short string without 
                                               blank spaces to identify the 
                                               process. There is no warranty of
                                               uniqueness, only if in the same 
                                               parent directory. If empty, 
                                               attribute test_x where x is 
                                               incremental integer.
    -c <comment>, --comment=<comment> Long string (enclosed in quotes) with the 
                                      process description. (optional) 

    -d <pz-compute directory>, --pz_compute_dir=<pz-compute directory> Full path
                                                       to pz-compute repository.
                                      
'''

import os
import sys
import argparse
import glob
from datetime import datetime


def main(): 
    

    # Initialize parser
    parser = argparse.ArgumentParser()
    # Adding optional argument
    parser.add_argument("-p", "--process_id", 
                        help = "Integer or short string without blank spaces") 
    parser.add_argument("-c", "--comment", 
                        help = "Comment with process description (enclosed in quotes)") 
    parser.add_argument("-d", "--pz_compute_dir", 
                        help = "Full path to pz-compute repository")
                                

    # Read arguments from command line
    args = parser.parse_args()
    if args.process_id:
        duplicate_id = os.path.isdir(args.process_id)
        if duplicate_id:
            print(f'Process {args.process_id} already exists!')
            print('Aborting...')
            quit()
    else: 
        old_process_ids = glob.glob('test_*') 
        if len(old_process_ids)>0:
            print('found duplicate') 
            old_n = []
            for old_process_id in old_process_ids:
                old_n.append(int(old_process_id.split('_')[-1]))
            max_id = max(old_n)
            args.process_id = 'test_'+ str(max_id+1)
        else:
            print('didnt find duplicate')
            args.process_id = 'test_0'


    print('---------------------------------------')
    print(f'Process ID: {args.process_id}')
    if not args.comment:
        args.comment = ' --- ' 
    print(f'Description: {args.comment}')
    print('---------------------------------------')
    print()
    process_dir = f'./{args.process_id}' 
    os.system(f'mkdir {process_dir}')
    os.system(f'mkdir {process_dir}/log')
    os.system(f'mkdir {process_dir}/input')
    os.system(f'mkdir {process_dir}/output')
   

    if not args.pz_compute_dir:
        #args.pz_compute_dir = input("Please type the full path to the pz-compute repository:") 
        pzdir = '/home/julia/github/pz-compute/'
        args.pz_compute_dir = pzdir

    os.system(f'ln -s {pzdir}/scheduler_examples/htcondor/rail-condor/rail-condor.py ./{args.process_id}/rail-condor.py')
    os.system(f'ln -s {pzdir}/scheduler_examples/htcondor/rail-condor/rail-condor-configure-paths.py ./{args.process_id}/rail-condor-configure-paths.py')
    os.system(f'cp {pzdir}/scheduler_examples/htcondor/rail-condor/rail-condor.sub ./{args.process_id}/rail-condor.sub')

    # WRITE JSON FILE   
    # FINISH WITH INSRUCTIONS TO RUN CONDOR SUBMIT 

    print('Running Photo-z Compute...' )
    print()
    # RAIL-CONDOR WILL UPDATE JSON FILE 
    start = datetime.now() # t.time() 
    print(f'Started at: {start}')

    quit()
    
    
    # TBD
    # call condor_submit (run in background!)
    
    # get finish time
    # save provenance file 
    # compute total duration 
    # get individual machines times from log file
    # print stats 
    # send notification email 
    

    print('Done!' )
    finish = datetime.now() # t.time() 
    print(f'Process finished at: {finish}')
    duration = finish - start 
    print('')
    print(f'Total duration: {duration}')
    print('')
    print(f'Process info saved in process_{args.process_id}.json' )





if __name__ == '__main__': main()


